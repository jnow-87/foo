\chapter{Architecture Abstraction\label{chap:arch}}
	The architecture interface implements an abstraction layer for the actual target hardware. It provides the interface between the target hardware and the kernel, cf. Chapter~\ref{chap:kernel}.


\section{Interface Header}
	\begin{description}
	\item[include/arch/arch.h]
		\hyperref[arch_2arch_8h]{include/arch/arch.h} is the main architecture header file. It provides access to the architecture implementation defined through \lstinline{CONFIG_ARCH_HEADER}. The header includes the respective architecture header and provides macros to call kernel and common functions as well as a macro to access architecture information.	
		\lstinputlisting[linerange={11-11,16-16,19-19}, numbers=none]{include/arch/arch.h}

	\item[include/arch/types.h]
		\hyperref[arch_2types_8h]{include/arch/types.h} defines the types containing the architecture interface callback functions. That is \hyperref[structarch__callbacks__kernel__t]{arch\_callbacks\_kernel\_t} for kernel and \hyperref[structarch__callbacks__common__t]{arch\_callbacks\_common\_t} for common callbacks.

	\item[include/arch/*]
		The remaining header files in \lstinline{include/arch} contain wrapper macros to access all of the architecture interface functions separately.
	\end{description}


\section{Defining an Architecture}
	The following is required to implement support for a target architecture.

	\subsection{Types}
		\begin{itemize}
			\item \lstinline{struct arch_info_t}: struct with architecture specific data, such as clock frequencies
			\item \lstinline{struct thread_context_t}: struct to store the processor context
			\item \lstinline{thread_id_t}: integer type for thread ids
			\item \lstinline{process_id_t}: integer type for process ids
			\item \lstinline{enum int_type_t}: enum for interrupt types, e.g. debug, machine check
			\item \lstinline{enum int_num_t}: enum of available interrupt
			\item \lstinline{timebase_t}: basic timer type
		\end{itemize}

	\subsection{Callback Functions}
		The callback functions are registers by defining variables of type \hyperref[structarch__callbacks__kernel__t]{arch\_callbacks\_kernel\_t} and \hyperref[structarch__callbacks__common__t]{arch\_callbacks\_common\_t} named \lstinline{arch_cbs_kernel} and \lstinline{arch_cbs_common}. Further, in order to get access to the architecture specific data, a variable of type \lstinline{arch_info_t}, named \lstinline{arch_info} needs to be declared.

	\subsection{Macros}
		\begin{itemize}
			\item \lstinline{NINTERRUPTS}: number of interrupts
			\item \lstinline{TIMEBASE_INITIALISER}: init value for variable of type \lstinline{timebase_t}\\
		\end{itemize}

	\subsection{Kconfig}
		\begin{itemize}
			\item respective \quote{Processor type} has to be added
			\item the following CONFIG-variables need to be defined
				\begin{itemize}
					\item \lstinline{CONFIG_ARCH}
					\item \lstinline{CONFIG_PROCESSOR}
					\item \lstinline{CONFIG_ADDR_WIDTH_*}
					\item \lstinline{CONFIG_ARCH_HEADER}
				\end{itemize}
		\end{itemize}

	\subsection{Build System}
		\begin{itemize}
			\item libsys.o shall containing all objects that are required to be linked against applications
			\item linker script scripts/linker/kernel\_$<$arch$>$.lds
			\item memory layout print (optional): scripts/memlayout/main.c, if target specific sections are required
				\begin{itemize}
					\item mandatory memory sections shall be printed using \lstinline{PRINT_RANGE_EE}
					\item optional memory sections shall be printed using \lstinline{PRINT_RANGE}
				\end{itemize}

			\item memory layout check: scripts/memlayout/check.c, if target specific sections shall be checked add them to the \lstinline{regs} array.
		\end{itemize}

\vfill
\pagebreak
\input{arch/avr}
